1.数字组合
源程序名 　　　compages .??? (PAS,C,CPP)
可执行文件名   compages .exe
输入文件名　　 comapges .in 
输出文件名     compages .out

[问题描述]：
在N个数中找出其和为M的若干个数。先读入正整数N（1<N<100）和M(1<M<10000)， 再读入N个正数（可以有相同的数字，每个数字均在1000以内）， 在这N个数中找出若干个数， 使它们的和是M， 把满足条件的数字组合都找出来以统计组合的个数，输出组合的个数（不考虑组合是否相同）。要求你的程序运行时间不超过1秒。

[输入]：
第一行是两个数字，表示N和M。
第二行起是N个数。

[输出]：
就一个数字，表示和为M的组合的个数。

[样例]：
compages .in
4  4
1  1  2  2

compages .out
3


2.波浪数
源程序名 　　　NUM.??? (PAS,C,CPP)
可执行文件名   NUM.EXE
输入文件名　　 NUM.IN 
输出文件名     NUM.OUT

波浪数是在一对数字之间交替转换的数，如1212121，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数191919是一个十进制下的波浪数，它对应的十一进制数121212也是一个波浪数，所以十进制数191919是一个双重波浪数。
	类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如十进制300=606（七进制）=363（九进制）=454（八进制）=1A1（十三进制）…，你的任务就是在指定范围内找出双重、三重、四重波浪数。

输入
	单独一行包含五个用空格隔开的十进制整数，前两个数表示进制的范围（2??32），第三与第四个数表示指定的范围（1??10000000），第五个数为2,3,4中的一个，表示要找的波浪数的重数。

输出
从小到大以十进制形式输出指定范围内的指定重数的波浪数。一行输出一个数。

样例
NUM.IN
10 11 190000 960000 2

NUM.OUT
191919
383838
575757
767676
959595

3.文件压缩
源程序名 　　　ZIP.??? (PAS,C,CPP)
可执行文件名   ZIP.EXE
输入文件名　　 ZIP.IN 
输出文件名     ZIP.OUT

提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。
该算法具体如下：对一个长度为n的字符串S，首先根据它构造n个字符串，其中第i个字符串由将S的前i-1个字符置于末尾得到。然后把这n个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们在S中的位置从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串S’，它的长度也是n，并且包含了S中的每一个字符。最后输出S’以及S的首字符在S’中的位置p。举例：
S:	example		
1、构造n个字符串
example
xamplee
ampleex
mpleexa
pleexam
leexamp
eexampl
2、将字符串排序
ampleex
example
eexampl
leexamp
mpleexa
pleexam
xamplee	
3、压缩结果
xelpame          S’
7                p
由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在S’中相同的字母有很大几率排在一起，从而提高S’的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。
     请你编一个程序，读入S’和p，输出字符串S。

输入
    输入文件共有三行，第1行是一个整数n（1<=n<=10000），代表S’的长度，第2行是字符串S’，第3行是整数p。

输出
     仅包含一行S。

样例
ZIP.IN
7
xelpame
7

ZIP.OUT
example

4.